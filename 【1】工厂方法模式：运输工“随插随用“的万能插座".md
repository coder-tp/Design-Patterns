
> 慢一点。你理解的越多，需要记的就越少。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6a12bcf8f1214710a69c2a82c91534a3.png#pic_center)
# 一、注重理解“why” 而不是“how”
## **场景**
你开发了一个爆款的物流管理应用，1.0版只支持​**​卡车运输​**​。代码的核心是一个`卡车`类，所有运输的逻辑（打包、路线规划、运费计算、发车通知等等）都写在这个类里，或者在它的旁边直接`new 卡车()`来处理运输请求。很直接，很干脆。

现在，用户呼声来了：“我们需要​**​海运​**​支持！”这是个好消息，也是个挑战。
## 二、它解决了什么问题？​**​ 什么场景下会产生这个痛点？**

>核心问题：对象创建的“紧耦合”和“缺乏扩展性”。​​

具体痛点场景：​**​ 在你的应用里，​**​所有需要运输的地方，代码都直接依赖于具体的`卡车`类。​**​ 当你要新增`海运`功能时，就麻烦了：

你需要修改 ​**​每一处​**​ 创建运输工具的地方。原来写着`new 卡车()`的地方，现在要改成：写一堆`if (运输类型 == "卡车") { 新建 卡车() } else if (运输类型 == "轮船") { 新建 轮船() }`。以后再加“空运”，就得再加`else if`。这意味着你要​**​翻遍整个代码库​**​去加判断语句。

运输工具创建的规则可能会变（比如卡车要区分不同吨位、船要区分集装箱船/散货船），这些创建逻辑会随着`if-else`的膨胀而散落在各处，​**​非常难维护​**​。

新增一种运输方式时，你需要​**​重新测试所有用到这段创建逻辑的代码​**​，风险很大。

>​**​总结痛点场景：​**​ 当你的代码需要创建 ​**​某种类型的产品（这里是运输工具）​**​，但未来 ​**​可能会新增该产品的不同具体变体（卡车、轮船、飞机等）​**​ 时，直接在产品使用的地方创建具体对象（`new 卡车()`）就会导致上述问题。


## 三、为什么常用解决方案不好？​**​ 会带来什么耦合、僵化或难以复用？

 ​**​强耦合：​**​ 应用的核心逻辑（如：调度、运输追踪、计费）​**​直接绑定​**​ 在了具体的`卡车`类上。调用方（核心逻辑）​**​必须知道`卡车`这个具体类的存在，并且知道怎么创建它。​**​

​**​僵化/违反开闭原则：​**​ 当需求变化（新增海运），你​**​被迫修改现有代码​**​（在每个创建点加`if-else`）而不是扩展它。这就违反了“对扩展开放，对修改关闭”的原则。系统难以适应变化。

​**​代码重复和散乱：​**​ 创建逻辑（尤其需要复杂初始化时）重复出现在多处。当创建规则变化（如初始化参数变了），所有地方都得改。

​**​难以复用：​**​ 核心的业务逻辑（调度、追踪等）是和运输工具有关的，但因为它与`卡车`具体类耦合太紧，你没办法直接​**​复用这部分逻辑​**​ 去处理`轮船`对象。你想复用？好，先改代码吧！

​**​测试困难：​**​ 核心逻辑依赖于真实的`卡车`创建和初始化行为，很难用模拟的（Mock）运输工具进行单元测试


## **​四、模式的方案如何解决这些问题？​**​ 它是如何松耦合、灵活扩展、支持复用的？
>工厂方法模式的核心思路是：​**​把对象创建的责任“外包”出去！​**​ 应用的核心代码不再操心`new卡车()`还是`new轮船()`了。

​**​具体方案步骤：​**​
1. ​**​定义产品接口：​**​ 创建一个`运输工具`接口（或抽象类）。这个接口声明了所有运输工具都必须实现的核心方法，比如`开始运输()`、`计算运费()`、`跟踪位置()`等。
2. ​**​创建具体产品类：​**​
    - `卡车`类：实现`运输工具`接口，包含卡车特有的实现。
    - `轮船`类：实现`运输工具`接口，包含轮船特有的实现。未来如果加飞机，就再实现一个`飞机`类。
3. ​**​定义创建者抽象/接口：​**​ 创建一个`物流工厂`接口（或抽象类）。这个接口​**​只声明​**​一个（或多个）方法，通常叫做`创建运输工具()`（Factory Method）。这个方法​**​只返回类型是`运输工具`接口​**​，并不具体说明创建哪种类型。
4. ​**​创建具体工厂类：​**​
    - `卡车物流工厂`类：实现`物流工厂`接口。它里面的`创建运输工具()`方法具体实现为`return 新建 卡车();`
    - `轮船物流工厂`类：实现`物流工厂`接口。它里面的`创建运输工具()`方法具体实现为`return 新建 轮船();`

**看模式如何解决问题：​**​

- ​**​松耦合：​**​ 应用的核心代码（调用方）现在​**​只依赖两个抽象的东西​**​：
    - `运输工具`接口：它告诉调用方运输工具能干什么。
    - `物流工厂`接口：它告诉调用方可以创建一个`运输工具`。
    - ​**​核心代码完全不关心​**​最后拿到的是卡车还是轮船，它只知道得到一个能`开始运输()`的`运输工具`。
- ​**​灵活扩展：​**​
    - ​**​新增运输方式？​**​ 超简单！比如加空运：
        - 创建新类`飞机`实现`运输工具`接口。
        - 创建新类`飞机物流工厂`实现`物流工厂`接口，它的`创建运输工具()`返回`new 飞机()`。
    - ​**​核心代码、卡车代码、轮船代码完全不需要动！​**​ 你只是在扩展系统，没有修改任何现有工作代码。这完全符合“开闭原则”。
- ​**​消除重复创建逻辑：​**​ 创建逻辑现在​**​集中封装​**​在每个具体的工厂（`卡车物流工厂`, `轮船物流工厂`）里。创建规则如果变化（比如卡车需要初始化车牌号、轮船需要初始化船籍港），只需要在具体的工厂类里修改。
- ​**​复用核心业务逻辑：​**​ 核心代码操作的是接口`运输工具`。只要是实现了这个接口的类型（卡车、轮船、飞机），核心代码​**​完全不用改就能直接处理它们！​**​ 复用性max！
- ​**​利于测试：​**​ 在测试核心代码时，你可以用一个实现了`物流工厂`接口的“测试工厂”，让它返回一个“模拟运输工具”。这样就能轻松隔离和测试核心逻辑，不必依赖真实的卡车/轮船。

## 五、它的优缺点和适用场景是什么？​**​ 没有万能模式，明确边界更重要。**

- **优点：​**​
    - ​**​极致的扩展性：​**​ 添加新产品类超容易，符合开闭原则。
    - ​**​解耦调用方和具体产品：​**​ 调用方只和抽象打交道。
    - ​**​代码集中：​**​ 将产品创建逻辑集中在一个地方（具体工厂）。
    - ​**​提升可测试性和复用性：​**​ 如上所述。
- ​**​缺点：​**​
    - ​**​增加类数量：​**​ 每新增一个产品，通常就要新增一个具体工厂类（虽然有时候可以优化）。这会让系统类数量增多，结构显得稍微复杂一点。简单工厂（用一个工厂类里的`if-else`或`switch`创建所有产品）会少一些类，但牺牲了扩展性。
    - ​**​有时略显繁琐：​**​ 对于非常简单的场景或者确定不会有扩展的情况，引入这个模式可能有点“杀鸡用牛刀”的感觉。
- ​**​适用场景：​**​
    - ​**​当你的代码需要创建对象，但无法预知确切的具体类型或依赖关系时。​**​ （比如这里的物流应用，用户要选择运输方式）。
    - ​**​当你要为库或框架的用户提供扩展其内部组件的方法时。​**​ （用户可以实现他们自己的具体工厂和产品）。
    - ​**​当你希望将产品创建逻辑从使用产品的代码中分离出来时。​**​
    - ​**​当你计划在将来添加新产品类型时。​**​ （预判！）
- ​**​不适用场景/注意：​**​
    - ​**​如果对象类型很少且固定不变：​**​ 过度设计，直接用简单工厂或直接new可能更直接。
    - ​**​如果创建逻辑极其简单（比如一个参数就能搞定）：​**​ 工厂方法的优势不明显。
    - ​**​关键点：明确未来变化的可能性！如果扩展是“很可能”，工厂方法就是好朋友；如果是“基本不可能”，可以暂缓使用。​**
## **​六、模式之间的关系？​**​ 

**与简单工厂：​**​ 工厂方法是简单工厂的升级版。简单工厂把所有创建逻辑塞到一个工厂类里（用条件判断创建不同产品），违背开闭原则。工厂方法让每个产品有自己的专属工厂，解决了这个问题。

**​与抽象工厂：​**​ 工厂方法是抽象工厂的一个基础组成部分。​**​抽象工厂模式通常包含多个工厂方法。​**​ 抽象工厂侧重于创建​**​一组相关的或依赖的产品族​**​（比如一套UI组件：按钮+文本框+下拉框需要搭配），而工厂方法侧重于创建​**​单一产品的不同变体​**​（这里是运输工具的不同类型）。你的物流工厂的`创建运输工具()`本身就是一个工厂方法。如果你未来还需要配套创建“运单”、“调度员”等一整套针对不同运输类型的组件，那就可能需要抽象工厂了。

**​与模板方法模式：​**​ 模板方法模式用于定义一个算法的骨架，将一些步骤延迟到子类实现。一个常见的用法是：在父类的模板方法里，​**​定义一个工厂方法来创建算法中所需的某个对象​**​，然后让子类去实现这个工厂方法。这样，父类控制了算法的流程，而子类决定了流程中某个特定环节所用的具体对象类型。

​**​与依赖注入：​**​ 依赖注入容器（如Spring）本质上是​**​工厂的超级强化版​**​，它不仅管理对象创建，还管理对象生命期和复杂的依赖关系注入。工厂方法模式的思想（通过接口获取实现）是依赖注入的基础理念之一。


## 七、总结
**原来：​**​ `应用核心代码` —（直接new）—> `卡车`​
**​痛点：​**​ 加`轮船`太痛苦，要到处改核心代码。​  

**​用工厂方法后：​**​
 `应用核心代码` —（调用方法）—> `物流工厂(接口)` —（具体实现）—> `卡车物流工厂.create()` -> `卡车 ` |—> `轮船物流工厂.create()` -> `轮船` ``
    
工厂方法让你的应用“以不变应万变”。核心流程（运输管理）永远只关心“运输工具”这个抽象概念和“能给我一个运输工具”的工厂接口。卡车也好，轮船也好，飞机也好，甚至未来的无人车、无人机，只要“穿上”`运输工具`接口这件“制服”，遵守“合同”（实现接口方法），并且有对应的“人事部”（具体工厂）负责“招聘”（创建），就能无缝融入你的系统工作。而你需要做的，只是开个新的“分公司”（具体工厂）去招募（创建）新“员工”（具体产品类）即可。系统的根基稳如泰山！  

# 八、小练习

> 做练习。自己做笔记。

```java
// 1. 定义产品接口：所有运输工具都要实现这个接口
interface Transport {
    void deliver(); // 核心方法：执行运输交付`
}

// 2. 实现具体产品类：卡车运输`
class Truck implements Transport {
    @Override
    public void deliver() {
        System.out.println("🚛 卡车正在公路上运输货物...");
    }
}

// 3. 实现具体产品类：轮船运输（新增需求）
class Ship implements Transport {
    @Override
    public void deliver() {
        System.out.println("🚢 轮船正在海上运输货物...");
    }
}

// 4. 定义创建者抽象类（核心工厂抽象）
abstract class LogisticsFactory {
    // 工厂方法（核心）：让子类决定具体创建哪种运输工具
    // 注意：这里返回的是抽象类型Transport，不是具体类
    public abstract Transport createTransport();
    
    // 模板方法：包装运输流程 (工厂模式常结合模板方法使用)
    public void planDelivery() {`
        System.out.println("📦 开始处理物流订单...");
        Transport transport = createTransport(); // 调用工厂方法创建运输工具
        transport.deliver();                     // 调用接口方法，不关心具体实现
        System.out.println("✅ 货物已成功送达目的地！");
    }
}

// 5. 具体工厂实现：卡车物流
class RoadLogistics extends LogisticsFactory {
    @Override
    public Transport createTransport() {
        System.out.println("🛞 创建卡车运输工具");
        return new Truck(); // 只关注卡车创建
    }
}

// 6. 具体工厂实现：海运物流（轻松扩展）
class SeaLogistics extends LogisticsFactory {
    @Override
    public Transport createTransport() {
        System.out.println("⚓ 创建轮船运输工具");
        return new Ship(); // 只关注轮船创建
    }
}

// 7. 客户端代码（应用核心）
public class LogisticsApp {
    public static void main(String[] args) {
        // 场景1：使用卡车运输`
        LogisticsFactory roadLogistics = new RoadLogistics();
        roadLogistics.planDelivery();
        /* 输出：
           📦 开始处理物流订单...
           🛞 创建卡车运输工具
           🚛 卡车正在公路上运输货物...
           ✅ 货物已成功送达目的地！
        */
        
        // 场景2：使用轮船运输（扩展时只需切换工厂）
        LogisticsFactory seaLogistics = new SeaLogistics();
        seaLogistics.planDelivery();
        /* 输出：
           📦 开始处理物流订单...
           ⚓ 创建轮船运输工具
           🚢 轮船正在海上运输货物...
           ✅ 货物已成功送达目的地！
        */
        
        // 🎯 关键优势：当需要新增空运时：
        // 1. 添加Airplane类实现Transport
        // 2. 创建AirLogistics继承LogisticsFactory
        // 3. 无需修改现有任何代码！`
    }
}

// 伪代码扩展示意（不需要实际运行）：
class Airplane implements Transport {
    public void deliver() { System.out.println("✈️ 飞机正在空运货物..."); }
}

class AirLogistics extends LogisticsFactory {
    public Transport createTransport() {
        return new Airplane(); // 轻松扩展第三类运输
    }
}
```
这个实现完美解决了之前的所有痛点：  
>1.新增运输方式不污染核心业务代码  
2.消除条件判断语句  
3.各运输方式创建逻辑各自封装  
4.所有Transport实现可以互换使用  
5.符合开闭原则（扩展开放，修改关闭）  
